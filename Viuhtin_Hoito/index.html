<!DOCTYPE html>
<html lang="fi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Viuhtin Hoito 3D - Hoida s√∂p√∂√§ collie-koiraa 3D-maailmassa!">
    <title>Viuhtin Hoito 3D - Koiranhoitopeli</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            overflow: hidden;
            color: white;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 70%;
            position: relative;
        }

        #game-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #music-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: absolute;
            top: 20px;
            right: 250px;
            /* Position to left of stats */
            z-index: 1000;
        }

        #music-btn:hover {
            transform: scale(1.1);
            background: rgba(0, 0, 0, 0.7);
        }

        /* UI Overlay */
        .ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
            z-index: 100;
        }

        .ui-overlay>* {
            pointer-events: auto;
        }

        .game-title {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .game-title h1 {
            font-size: 1.5rem;
            background: linear-gradient(45deg, #ff6b6b, #ffd93d);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Stats Panel */
        .stats-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 15px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            min-width: 200px;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }

        .stat-icon {
            font-size: 1.2rem;
        }

        .stat-bar-container {
            flex: 1;
            height: 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            overflow: hidden;
        }

        .stat-bar {
            height: 100%;
            border-radius: 6px;
            transition: width 0.5s ease;
        }

        .stat-bar.hunger {
            background: linear-gradient(90deg, #ff6b6b, #ff8e53);
        }

        .stat-bar.energy {
            background: linear-gradient(90deg, #4facfe, #00f2fe);
        }

        .stat-bar.happiness {
            background: linear-gradient(90deg, #f093fb, #f5576c);
        }

        .stat-bar.bladder {
            background: linear-gradient(90deg, #a8eb12, #aaffa9);
        }

        /* Room Navigation */
        .room-nav {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 10px 20px;
            border-radius: 25px;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .room-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            padding: 10px 15px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 1.1rem;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            transition: all 0.3s ease;
        }

        .room-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-3px);
        }

        .room-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        .room-btn span.icon {
            font-size: 1.5rem;
        }

        .room-btn span.label {
            font-size: 0.7rem;
            font-weight: 600;
        }

        /* Actions Panel */
        .actions-panel {
            height: 30%;
            min-height: 180px;
            /* Ensure space */
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, rgba(20, 20, 40, 1) 100%);
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 10px;
            overflow-y: auto;
            /* Enable scrolling for buttons */
        }

        .actions-title {
            font-size: 1rem;
            font-weight: 700;
            color: #ffd93d;
            margin-bottom: 5px;
        }

        .actions-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            flex: 1;
        }

        .action-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            transition: all 0.3s ease;
            color: white;
        }

        .action-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2), rgba(255, 255, 255, 0.1));
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .action-btn:active {
            transform: scale(0.95);
        }

        .action-btn .icon {
            font-size: 1.8rem;
        }

        .action-btn .label {
            font-size: 0.7rem;
            font-weight: 600;
        }

        .action-btn.walk-btn {
            background: linear-gradient(135deg, #56ab2f, #a8e063);
            border-color: #56ab2f;
        }

        .action-btn.poop-btn {
            background: linear-gradient(135deg, #8B4513, #D2691E);
            border-color: #8B4513;
        }

        /* Speech Bubble */
        .speech-bubble {
            position: absolute;
            background: white;
            color: #333;
            padding: 10px 15px;
            border-radius: 20px;
            font-weight: 600;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            opacity: 0;
            transform: translateY(10px);
            transition: all 0.3s ease;
            z-index: 200;
            pointer-events: none;
        }

        .speech-bubble.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .speech-bubble::after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            border: 10px solid transparent;
            border-top-color: white;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            padding: 20px 40px;
            border-radius: 20px;
            border: 2px solid #ffd93d;
            font-size: 1.2rem;
            font-weight: 700;
            text-align: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 300;
        }

        .notification.visible {
            opacity: 1;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-dog {
            font-size: 4rem;
            animation: bounce 1s infinite;
        }

        .loading-text {
            font-size: 1.5rem;
            margin-top: 20px;
            color: #ffd93d;
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        /* Animation overlay for poop */
        .poop-animation {
            position: fixed;
            font-size: 5rem;
            z-index: 500;
            animation: poopFall 1.5s ease-in forwards;
            pointer-events: none;
        }

        @keyframes poopFall {
            0% {
                opacity: 0;
                transform: translateY(-50px) scale(0.5);
            }

            30% {
                opacity: 1;
                transform: translateY(0) scale(1.2);
            }

            50% {
                transform: translateY(20px) scale(1);
            }

            100% {
                opacity: 0;
                transform: translateY(100px) scale(0.8);
            }
        }

        @media (max-width: 768px) {
            .actions-panel {
                height: 45%;
                /* More space for buttons on mobile */
                padding: 10px;
            }

            .actions-grid {
                grid-template-columns: repeat(3, 1fr);
                /* 3 columns to fit all buttons visibly */
                gap: 5px;
            }

            .action-btn {
                padding: 5px;
            }

            .action-btn .icon {
                font-size: 1.4rem;
            }

            .action-btn .label {
                font-size: 0.65rem;
            }

            .room-btn span.label {
                display: none;
            }

            .room-nav {
                padding: 5px 10px;
                bottom: 5px;
            }

            .room-btn {
                padding: 5px 10px;
            }
        }
    </style>
</head>

<body>
    <div id="game-container">
        <!-- Loading Screen -->
        <div class="loading-screen" id="loading-screen">
            <div class="loading-dog">üêï</div>
            <div class="loading-text">Ladataan Viuhtin maailmaa...</div>
        </div>

        <!-- 3D Canvas -->
        <div id="canvas-container">
            <canvas id="game-canvas"></canvas>

            <!-- UI Overlay -->
            <div class="ui-overlay">
                <div class="game-title">
                    <h1>üêï Viuhtin Hoito 3D</h1>
                </div>
            </div>

            <button id="music-btn" title="Musiikki P√§√§ll√§/Pois">üîá</button>

            <!-- Stats Panel -->
            <div class="stats-panel">
                <div class="stat-item">
                    <span class="stat-icon">üçñ</span>
                    <div class="stat-bar-container">
                        <div class="stat-bar hunger" id="hunger-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üí§</span>
                    <div class="stat-bar-container">
                        <div class="stat-bar energy" id="energy-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">‚ù§Ô∏è</span>
                    <div class="stat-bar-container">
                        <div class="stat-bar happiness" id="happiness-bar" style="width: 100%"></div>
                    </div>
                </div>
                <div class="stat-item">
                    <span class="stat-icon">üöΩ</span>
                    <div class="stat-bar-container">
                        <div class="stat-bar bladder" id="bladder-bar" style="width: 30%"></div>
                    </div>
                </div>
            </div>

            <!-- Room Navigation -->
            <div class="room-nav">
                <button class="room-btn active" data-room="living">
                    <span class="icon">üè†</span>
                    <span class="label">Olohuone</span>
                </button>
                <button class="room-btn" data-room="kitchen">
                    <span class="icon">üç≥</span>
                    <span class="label">Keitti√∂</span>
                </button>
                <button class="room-btn" data-room="bathroom">
                    <span class="icon">üõÅ</span>
                    <span class="label">Kylpyhuone</span>
                </button>
                <button class="room-btn" data-room="bedroom">
                    <span class="icon">üõèÔ∏è</span>
                    <span class="label">Makuuhuone</span>
                </button>
                <button class="room-btn" data-room="yard">
                    <span class="icon">üå≥</span>
                    <span class="label">Piha</span>
                </button>
            </div>

            <!-- Speech Bubble -->
            <div class="speech-bubble" id="speech-bubble">Hau hau! üêï</div>
        </div>

        <!-- Actions Panel -->
        <div class="actions-panel">
            <div class="actions-title">üéÆ Toiminnot</div>
            <div class="actions-grid">
                <button class="action-btn" id="btn-feed">
                    <span class="icon">üçñ</span>
                    <span class="label">Ruoki</span>
                </button>
                <button class="action-btn" id="btn-water">
                    <span class="icon">üíß</span>
                    <span class="label">Vett√§</span>
                </button>
                <button class="action-btn" id="btn-pet">
                    <span class="icon">ü§≤</span>
                    <span class="label">Rapsuta</span>
                </button>
                <button class="action-btn" id="btn-play">
                    <span class="icon">üéæ</span>
                    <span class="label">Leiki</span>
                </button>
                <button class="action-btn walk-btn" id="btn-walk">
                    <span class="icon">üö∂</span>
                    <span class="label">Ulkoiluta</span>
                </button>
                <button class="action-btn poop-btn" id="btn-poop">
                    <span class="icon">üí©</span>
                    <span class="label">Kakka</span>
                </button>
                <button class="action-btn" id="btn-cleanup"
                    style="background: linear-gradient(135deg, #2196F3, #4CAF50);">
                    <span class="icon">üßπ</span>
                    <span class="label">Siivoa</span>
                </button>
                <button class="action-btn" id="btn-nails"
                    style="background: linear-gradient(135deg, #FF69B4, #FF1493);">
                    <span class="icon">‚úÇÔ∏è</span>
                    <span class="label">Kynnet</span>
                </button>
                <button class="action-btn" id="btn-heal" style="background: linear-gradient(135deg, #E91E63, #9C27B0);">
                    <span class="icon">ü©π</span>
                    <span class="label">Hoida</span>
                </button>
                <button class="action-btn" id="btn-brush"
                    style="background: linear-gradient(135deg, #FF9800, #F57C00);">
                    <span class="icon">ü™Æ</span>
                    <span class="label">Harjaa</span>
                </button>
                <button class="action-btn" id="btn-teeth"
                    style="background: linear-gradient(135deg, #00BCD4, #0097A7);">
                    <span class="icon">ü™•</span>
                    <span class="label">Hampaat</span>
                </button>
            </div>
        </div>

        <!-- Notification -->
        <div class="notification" id="notification"></div>
    </div>

    <!-- Three.js -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

    <script>
        // ============================================
        // GAME STATE
        // ============================================
        const gameState = {
            stats: {
                hunger: 100,
                energy: 100,
                happiness: 100,
                bladder: 30
            },
            currentRoom: 'living',
            isAnimating: false,
            dogPosition: { x: 0, y: 0, z: 0 },
            poopObjects: [],  // Track poop in scene for cleanup
            hasLeash: false,  // Track if leash is attached
            injuries: []      // Track wounds/splinters on the dog
        };

        // Injury types
        const injuryTypes = [
            { type: 'splinter', name: 'Tikku tassusta', emoji: 'ü™µ', location: 'paw' },
            { type: 'wound', name: 'Haava', emoji: 'ü©∏', location: 'body' },
            { type: 'thorn', name: 'Piikki', emoji: 'üåπ', location: 'paw' },
            { type: 'scratch', name: 'Naarmu', emoji: 'üòø', location: 'body' }
        ];

        // ============================================
        // AUDIO SYSTEM üéµ
        // ============================================
        const MusicEngine = {
            audioCtx: null,
            isPlaying: false,
            gainNode: null,
            nextNoteTime: 0,
            noteIndex: 0,
            tempo: 100,
            melody: [
                // Simple happy melody in C major
                { note: 'C4', duration: 4 }, { note: 'E4', duration: 4 }, { note: 'G4', duration: 4 }, { note: 'C5', duration: 2 }, { note: 'G4', duration: 2 },
                { note: 'A4', duration: 4 }, { note: 'G4', duration: 8 },
                { note: 'F4', duration: 4 }, { note: 'A4', duration: 4 }, { note: 'G4', duration: 4 }, { note: 'E4', duration: 4 },
                { note: 'D4', duration: 4 }, { note: 'E4', duration: 4 }, { note: 'C4', duration: 8 }
            ],

            frequencies: {
                'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
                'C5': 523.25
            },

            init: function () {
                try {
                    const AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioCtx = new AudioContext();
                    this.gainNode = this.audioCtx.createGain();
                    this.gainNode.gain.value = 0.3; // Louder volume (req: v√§h√§n kovemmalle)
                    this.gainNode.connect(this.audioCtx.destination);
                } catch (e) {
                    console.error('Web Audio API not supported');
                }

                // Button handler
                const btn = document.getElementById('music-btn');

                btn.addEventListener('click', () => {
                    this.toggle();
                    btn.textContent = this.isPlaying ? 'üîä' : 'üîá';
                });

                // Auto-start on first interaction (browser policy workaround)
                const enableAudio = () => {
                    if (this.audioCtx && this.audioCtx.state === 'suspended') {
                        this.audioCtx.resume();
                    }
                    if (!this.isPlaying) {
                        this.isPlaying = true; // Default ON
                        this.nextNoteTime = this.audioCtx.currentTime + 0.1;
                        this.scheduler();
                        btn.textContent = 'üîä';
                    }
                    document.removeEventListener('click', enableAudio);
                    document.removeEventListener('touchstart', enableAudio);
                };

                // Listen for first user gesture
                document.addEventListener('click', enableAudio);
                document.addEventListener('touchstart', enableAudio);
            },

            toggle: function () {
                if (!this.audioCtx) this.init();

                if (this.audioCtx.state === 'suspended') {
                    this.audioCtx.resume();
                }

                this.isPlaying = !this.isPlaying;

                if (this.isPlaying) {
                    this.nextNoteTime = this.audioCtx.currentTime;
                    this.scheduler();
                } else {
                    // Stop logic handled by not scheduling more notes
                }
            },

            playNote: function (freq, duration) {
                const osc = this.audioCtx.createOscillator();
                const noteGain = this.audioCtx.createGain();

                osc.type = 'sine'; // Soft sine wave
                osc.frequency.value = freq;

                // Envelope
                noteGain.gain.setValueAtTime(0, this.audioCtx.currentTime);
                noteGain.gain.linearRampToValueAtTime(0.1, this.audioCtx.currentTime + 0.1);
                noteGain.gain.exponentialRampToValueAtTime(0.001, this.audioCtx.currentTime + duration);

                osc.connect(noteGain);
                noteGain.connect(this.gainNode);

                osc.start(this.audioCtx.currentTime);
                osc.stop(this.audioCtx.currentTime + duration);
            },

            scheduler: function () {
                if (!this.isPlaying) return;

                while (this.nextNoteTime < this.audioCtx.currentTime + 0.1) {
                    const beat = this.melody[this.noteIndex];
                    if (beat && this.frequencies[beat.note]) {
                        this.playNote(this.frequencies[beat.note], beat.duration * (60 / this.tempo));
                    }

                    this.nextNoteTime += (beat ? beat.duration : 4) * (60 / this.tempo) * 0.25; // 0.25 is because duration 4 = quarter note

                    this.noteIndex++;
                    if (this.noteIndex >= this.melody.length) {
                        this.noteIndex = 0;
                    }
                }

                setTimeout(() => this.scheduler(), 25);
            }
        };

        // Initialize Audio
        window.addEventListener('load', () => MusicEngine.init());

        // ============================================
        // THREE.JS SETUP
        // ============================================
        let scene, camera, renderer;
        let dog, room;
        let animationId;
        let dogMixer;

        // Room positions
        const roomPositions = {
            living: { x: 0, y: 0, z: 0, color: 0x4a5568 },
            kitchen: { x: 8, y: 0, z: 0, color: 0x48bb78 },
            bathroom: { x: -8, y: 0, z: 0, color: 0x4299e1 },
            bedroom: { x: 0, y: 0, z: 8, color: 0x9f7aea },
            yard: { x: 0, y: 0, z: -10, color: 0x68d391, isOutside: true }
        };

        function init() {
            // Scene
            scene = new THREE.Scene();

            // Camera
            const container = document.getElementById('canvas-container');
            camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 8, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('game-canvas'),
                antialias: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x1a1a2e);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0xffd93d, 0.5, 20);
            pointLight.position.set(0, 5, 0);
            scene.add(pointLight);

            // Create room
            createRoom('living');

            // Create dog
            createDog();

            // Start animation loop
            animate();

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading-screen').classList.add('hidden');
            }, 1000);

            // Handle resize
            window.addEventListener('resize', onWindowResize);
        }

        function createRoom(roomId) {
            // Clear previous room
            if (room) {
                scene.remove(room);
            }

            room = new THREE.Group();
            const roomData = roomPositions[roomId];

            if (roomData.isOutside) {
                // Outdoor scene - yard
                createYard();
            } else {
                // Indoor room
                createIndoorRoom(roomData.color);
            }

            scene.add(room);
        }

        function createIndoorRoom(floorColor) {
            // Floor
            const floorGeometry = new THREE.PlaneGeometry(15, 15);
            const floorMaterial = new THREE.MeshStandardMaterial({
                color: floorColor,
                roughness: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            room.add(floor);

            // Walls
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0xe2e8f0,
                roughness: 0.9
            });

            // Back wall
            const backWall = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 8),
                wallMaterial
            );
            backWall.position.set(0, 4, -7.5);
            room.add(backWall);

            // Left wall
            const leftWall = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 8),
                wallMaterial
            );
            leftWall.position.set(-7.5, 4, 0);
            leftWall.rotation.y = Math.PI / 2;
            room.add(leftWall);

            // Right wall
            const rightWall = new THREE.Mesh(
                new THREE.PlaneGeometry(15, 8),
                wallMaterial
            );
            rightWall.position.set(7.5, 4, 0);
            rightWall.rotation.y = -Math.PI / 2;
            room.add(rightWall);

            // Add some furniture based on room
            addFurniture(gameState.currentRoom);
        }

        function createYard() {
            // Realistic Grass Ground with variation
            const grassGeometry = new THREE.PlaneGeometry(40, 40, 20, 20);

            // Add slight bumpiness to ground vertices
            const positionAttribute = grassGeometry.getAttribute('position');
            const vertex = new THREE.Vector3();
            for (let i = 0; i < positionAttribute.count; i++) {
                vertex.fromBufferAttribute(positionAttribute, i);
                vertex.z += (Math.random() - 0.5) * 0.2; // Slight height variation
                positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
            }

            const grassMaterial = new THREE.MeshStandardMaterial({
                color: 0x4caf50,
                roughness: 1,
                flatShading: true
            });
            const grass = new THREE.Mesh(grassGeometry, grassMaterial);
            grass.rotation.x = -Math.PI / 2;
            grass.receiveShadow = true;
            room.add(grass);

            // Sky & Environment
            renderer.setClearColor(0x87CEEB);

            // White Picket Fence
            createFence();

            // Trees with variation
            for (let i = 0; i < 8; i++) {
                const scale = 0.8 + Math.random() * 0.5;
                const x = (Math.random() - 0.5) * 30;
                const z = (Math.random() - 0.5) * 30;

                // Keep center area clear
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;

                createDetailedTree(x, 0, z, scale);
            }

            // Bushes
            for (let i = 0; i < 12; i++) {
                createBush(
                    (Math.random() - 0.5) * 35,
                    0,
                    (Math.random() - 0.5) * 35
                );
            }

            // Simple Stone Path
            const pathGeo = new THREE.CircleGeometry(0.4, 6);
            const pathMat = new THREE.MeshStandardMaterial({ color: 0x808080 });

            for (let i = -8; i < 8; i += 1.2) {
                const stone = new THREE.Mesh(pathGeo, pathMat);
                stone.rotation.x = -Math.PI / 2;
                stone.position.set((Math.random() - 0.5) * 0.5, 0.02, i);
                stone.scale.set(1, (0.8 + Math.random() * 0.4), 1);
                room.add(stone);
            }

            // Dog House
            createDogHouse(-5, 0, -5);
        }

        function createFence() {
            const postGeo = new THREE.BoxGeometry(0.2, 1.2, 0.2);
            const railGeo = new THREE.BoxGeometry(10, 0.1, 0.1);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

            const size = 18;

            // Posts
            for (let i = -size; i <= size; i += 2) {
                [-size, size].forEach(z => {
                    const post = new THREE.Mesh(postGeo, mat);
                    post.position.set(i, 0.6, z);
                    room.add(post);

                    const postSide = new THREE.Mesh(postGeo, mat);
                    postSide.position.set(z, 0.6, i);
                    room.add(postSide);
                });
            }
        }

        function createDetailedTree(x, y, z, scale) {
            const treeGroup = new THREE.Group();

            // Trunk with texture/color variation
            const trunkGeometry = new THREE.CylinderGeometry(0.2 * scale, 0.3 * scale, 1.5 * scale, 8);
            const trunkMaterial = new THREE.MeshStandardMaterial({ color: 0x5D4037 });
            const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
            trunk.position.y = 0.75 * scale;
            treeGroup.add(trunk);

            // Foliage - multiple spheres for fluffiness
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.8 });

            const positions = [
                { x: 0, y: 2, z: 0, s: 1.2 },
                { x: 0.5, y: 1.5, z: 0.5, s: 0.9 },
                { x: -0.5, y: 1.5, z: 0.5, s: 0.9 },
                { x: 0.5, y: 1.5, z: -0.5, s: 0.9 },
                { x: -0.5, y: 1.5, z: -0.5, s: 0.9 },
                { x: 0, y: 2.5, z: 0, s: 0.8 }
            ];

            positions.forEach(pos => {
                const leaf = new THREE.Mesh(new THREE.DodecahedronGeometry(pos.s * scale), leafMat);
                leaf.position.set(pos.x * scale * 0.5, pos.y * scale, pos.z * scale * 0.5);
                treeGroup.add(leaf);
            });

            treeGroup.position.set(x, y, z);
            room.add(treeGroup);
        }

        function createBush(x, y, z) {
            const bushGeo = new THREE.DodecahedronGeometry(0.6);
            const bushMat = new THREE.MeshStandardMaterial({ color: 0x558B2F });
            const bush = new THREE.Mesh(bushGeo, bushMat);
            bush.position.set(x, 0.4, z);
            bush.scale.set(1 + Math.random() * 0.5, 0.8 + Math.random() * 0.4, 1 + Math.random() * 0.5);
            room.add(bush);
        }

        function createDogHouse(x, y, z) {
            const houseGroup = new THREE.Group();

            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(2, 1.5, 2.5),
                new THREE.MeshStandardMaterial({ color: 0xF5DEB3 }) // Wheat color
            );
            base.position.y = 0.75;
            houseGroup.add(base);

            // Roof
            const roof = new THREE.Mesh(
                new THREE.ConeGeometry(2, 1, 4),
                new THREE.MeshStandardMaterial({ color: 0x8B0000 }) // Dark red
            );
            roof.position.y = 2;
            roof.rotation.y = Math.PI / 4;
            roof.scale.z = 1.4;
            houseGroup.add(roof);

            // Door hole (black box)
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            door.position.set(0, 0.5, 1.26);
            houseGroup.add(door);

            // Sign
            const sign = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.3, 0.1),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            sign.position.set(0, 1.2, 1.3);
            houseGroup.add(sign);

            houseGroup.position.set(x, y, z);
            houseGroup.rotation.y = Math.PI / 6;
            room.add(houseGroup);
        }

        // Room Helper Functions
        function createBaseboards(room) {
            const boardGeo = new THREE.BoxGeometry(15, 0.4, 0.1);
            const boardMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });

            // Back
            const back = new THREE.Mesh(boardGeo, boardMat);
            back.position.set(0, 0.2, -7.45);
            room.add(back);

            // Left (partial for door)
            const left = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 15), boardMat);
            left.position.set(-7.45, 0.2, 0);
            room.add(left);

            // Right
            const right = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 15), boardMat);
            right.position.set(7.45, 0.2, 0);
            room.add(right);
        }

        function createWindow(x, y, z, rotY) {
            const group = new THREE.Group();

            // Frame
            const frameGeo = new THREE.BoxGeometry(3, 2, 0.2);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xFFFFFF });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            group.add(frame);

            // Glass/Sky "view"
            const glassGeo = new THREE.PlaneGeometry(2.6, 1.6);
            const glassMat = new THREE.MeshBasicMaterial({ color: 0x87CEEB }); // Sky blue view
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.position.z = 0.11;
            group.add(glass);

            // Cross bars
            const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.6, 0.05), frameMat);
            vBar.position.z = 0.15;
            group.add(vBar);

            const hBar = new THREE.Mesh(new THREE.BoxGeometry(2.6, 0.1, 0.05), frameMat);
            hBar.position.z = 0.15;
            group.add(hBar);

            group.position.set(x, y, z);
            group.rotation.y = rotY;
            room.add(group);
        }

        function createPainting(x, y, z, rotY, color) {
            const group = new THREE.Group();

            // Frame
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(1.5, 2, 0.1),
                new THREE.MeshStandardMaterial({ color: 0x2d1b0e }) // Dark wood
            );
            group.add(frame);

            // Canvas
            const canvas = new THREE.Mesh(
                new THREE.PlaneGeometry(1.2, 1.7),
                new THREE.MeshStandardMaterial({ color: color })
            );
            canvas.position.z = 0.06;
            group.add(canvas);

            group.position.set(x, y, z);
            group.rotation.y = rotY;
            room.add(group);
        }

        function addFurniture(roomId) {
            // Common elements
            createBaseboards(room);

            switch (roomId) {
                case 'living':
                    // Wooden floor pattern with planks
                    const floorPattern = new THREE.Mesh(
                        new THREE.PlaneGeometry(14, 14),
                        new THREE.MeshStandardMaterial({
                            color: 0xB8860B,
                            roughness: 0.6
                        })
                    );
                    floorPattern.rotation.x = -Math.PI / 2;
                    floorPattern.position.y = 0.01;
                    room.add(floorPattern);

                    // Windows and Decorations
                    createWindow(-7.4, 2.5, -2, Math.PI / 2);
                    createPainting(4, 2.5, -7.4, 0, 0x4682B4); // Blue painting

                    // Cozy rug
                    const rug = new THREE.Mesh(
                        new THREE.CylinderGeometry(3.5, 3.5, 0.05, 32),
                        new THREE.MeshStandardMaterial({ color: 0x8B0000, roughness: 1 })
                    );
                    rug.position.set(0, 0.03, 0);
                    room.add(rug);

                    // Modern L-shaped sofa
                    const sofaGroup = new THREE.Group();
                    const sofaBase = new THREE.Mesh(new THREE.BoxGeometry(4.5, 0.6, 1.8), new THREE.MeshStandardMaterial({ color: 0x4A5568 }));
                    sofaBase.position.set(0, 0.3, -5);
                    sofaGroup.add(sofaBase);

                    const sofaSide = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.6, 3), new THREE.MeshStandardMaterial({ color: 0x4A5568 }));
                    sofaSide.position.set(1.35, 0.3, -2.6);
                    sofaGroup.add(sofaSide);

                    const sofaBack = new THREE.Mesh(new THREE.BoxGeometry(4.5, 1.2, 0.4), new THREE.MeshStandardMaterial({ color: 0x4A5568 }));
                    sofaBack.position.set(0, 0.9, -5.7);
                    sofaGroup.add(sofaBack);

                    // Sofa cushions
                    [-1.2, 0, 1.2].forEach(x => {
                        const cushion = new THREE.Mesh(new THREE.BoxGeometry(1, 0.3, 1.4), new THREE.MeshStandardMaterial({ color: 0x718096 }));
                        cushion.position.set(x, 0.75, -5);
                        sofaGroup.add(cushion);
                    });

                    room.add(sofaGroup);

                    // Coffee table
                    const tableTop = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 0.1, 1.2),
                        new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.4 })
                    );
                    tableTop.position.set(-0.5, 0.5, -2.5);
                    room.add(tableTop);

                    // Table legs
                    [[-0.8, -0.4], [-0.8, 0.4], [0.8, -0.4], [0.8, 0.4]].forEach(([x, z]) => {
                        const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.45, 8), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
                        leg.position.set(-0.5 + x, 0.225, -2.5 + z);
                        room.add(leg);
                    });

                    // TV Area
                    const tvStand = new THREE.Mesh(new THREE.BoxGeometry(4, 0.6, 0.5), new THREE.MeshStandardMaterial({ color: 0x2D3748 }));
                    tvStand.position.set(0, 0.3, -7);
                    room.add(tvStand);

                    const tvScreen = new THREE.Mesh(new THREE.BoxGeometry(3.5, 2, 0.1), new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1, metalness: 0.5 }));
                    tvScreen.position.set(0, 1.6, -7.2);
                    room.add(tvScreen);

                    // Bookshelf
                    const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 0.4), new THREE.MeshStandardMaterial({ color: 0xCD853F }));
                    shelf.position.set(-6, 1.5, -5);
                    room.add(shelf);

                    // Simple books
                    for (let i = 0; i < 8; i++) {
                        const book = new THREE.Mesh(
                            new THREE.BoxGeometry(0.15, 0.4, 0.3),
                            new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff })
                        );
                        book.position.set(-6.3 + (i % 4) * 0.35, 1 + Math.floor(i / 4) * 1, -5);
                        room.add(book);
                    }

                    // Potted Plant
                    const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.2, 0.4), new THREE.MeshStandardMaterial({ color: 0xD2691E }));
                    pot.position.set(6, 0.2, -6);
                    room.add(pot);

                    const plant = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6), new THREE.MeshStandardMaterial({ color: 0x228B22 }));
                    plant.position.set(6, 0.7, -6);
                    room.add(plant);
                    break;

                case 'kitchen':
                    // Checkerboard floor
                    const tiles = new THREE.Mesh(
                        new THREE.PlaneGeometry(14, 14),
                        new THREE.MeshStandardMaterial({ color: 0xF5F5DC })
                    );
                    tiles.rotation.x = -Math.PI / 2;
                    tiles.position.y = 0.01;
                    room.add(tiles);

                    createWindow(0, 2.5, -7.4, 0);

                    // Kitchen units
                    const counter = new THREE.Mesh(new THREE.BoxGeometry(14, 1, 1), new THREE.MeshStandardMaterial({ color: 0xDDDDDD }));
                    counter.position.set(0, 0.5, -6.5);
                    room.add(counter);

                    // Fridge
                    const fridge = new THREE.Mesh(new THREE.BoxGeometry(1.5, 2.8, 1), new THREE.MeshStandardMaterial({ color: 0xE0E0E0, metalness: 0.3 }));
                    fridge.position.set(-5, 1.4, -6);
                    room.add(fridge);

                    // Stove & Oven
                    const stove = new THREE.Mesh(new THREE.BoxGeometry(1.2, 1.1, 1), new THREE.MeshStandardMaterial({ color: 0x333333 }));
                    stove.position.set(2, 0.55, -6.5);
                    room.add(stove);

                    // Pot on stove
                    const potC = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.2), new THREE.MeshStandardMaterial({ color: 0xB87333 }));
                    potC.position.set(2.2, 1.2, -6.5);
                    room.add(potC);

                    // Kitchen Table with tablecloth
                    const table = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.05, 32), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    table.position.set(0, 0.9, 0);
                    room.add(table);

                    const tableLeg = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.4, 0.9), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
                    tableLeg.position.set(0, 0.45, 0);
                    room.add(tableLeg);

                    // Fruit bowl
                    const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x8B4513, side: THREE.DoubleSide }));
                    bowl.rotation.x = Math.PI;
                    bowl.position.set(0, 0.95, 0);
                    room.add(bowl);

                    const apple = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshStandardMaterial({ color: 0xFF0000 }));
                    apple.position.set(0, 1.05, 0);
                    room.add(apple);

                    // Dog bowls
                    const waterBowl = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.15), new THREE.MeshStandardMaterial({ color: 0x4169E1 }));
                    waterBowl.position.set(-3, 0.08, 4);
                    room.add(waterBowl);

                    const foodBowl = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.15), new THREE.MeshStandardMaterial({ color: 0xDC143C }));
                    foodBowl.position.set(-1.5, 0.08, 4);
                    room.add(foodBowl);
                    break;

                case 'bathroom':
                    // Blue tile floor
                    const bathTiles = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), new THREE.MeshStandardMaterial({ color: 0xE0F7FA }));
                    bathTiles.rotation.x = -Math.PI / 2;
                    bathTiles.position.y = 0.01;
                    room.add(bathTiles);

                    // Bathtub
                    const tub = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.8, 1.2), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    tub.position.set(-4.5, 0.4, 0);
                    room.add(tub);

                    // Water
                    const water = new THREE.Mesh(new THREE.PlaneGeometry(2.3, 1), new THREE.MeshStandardMaterial({ color: 0x4FC3F7, transparent: true, opacity: 0.6 }));
                    water.rotation.x = -Math.PI / 2;
                    water.position.set(-4.5, 0.7, 0);
                    room.add(water);

                    // Rubber Duck
                    const duck = new THREE.Mesh(new THREE.SphereGeometry(0.15), new THREE.MeshStandardMaterial({ color: 0xFFEB3B }));
                    duck.position.set(-4.5, 0.75, 0.2);
                    room.add(duck);

                    // Vanity
                    const vanity = new THREE.Mesh(new THREE.BoxGeometry(1.6, 1, 0.8), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    vanity.position.set(0, 0.5, -6.5);
                    room.add(vanity);

                    const mirror = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 1.8), new THREE.MeshStandardMaterial({ color: 0xBBDEFB, metalness: 0.9, roughness: 0.1 }));
                    mirror.position.set(0, 1.8, -6.9);
                    room.add(mirror);

                    // Toilet
                    const toilet = new THREE.Group();
                    const toiletBase = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.35, 0.5), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    toiletBase.position.y = 0.25;
                    toilet.add(toiletBase);
                    const toiletTank = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.8, 0.3), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    toiletTank.position.set(0, 0.7, -0.4);
                    toilet.add(toiletTank);
                    toilet.position.set(4, 0, -5);
                    room.add(toilet);

                    // Rug
                    const bathRug = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 1 }));
                    bathRug.rotation.x = -Math.PI / 2;
                    bathRug.position.set(0, 0.02, 0);
                    room.add(bathRug);
                    break;

                case 'bedroom':
                    // Carpet
                    const carpet = new THREE.Mesh(new THREE.PlaneGeometry(14, 14), new THREE.MeshStandardMaterial({ color: 0xF5DEB3, roughness: 1 }));
                    carpet.rotation.x = -Math.PI / 2;
                    carpet.position.y = 0.01;
                    room.add(carpet);

                    createWindow(0, 2.5, -7.4, 0);

                    // Bed
                    const bedGroup = new THREE.Group();
                    const mattress = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5, 4.5), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    mattress.position.y = 0.5;
                    bedGroup.add(mattress);

                    const blanket = new THREE.Mesh(new THREE.BoxGeometry(3.6, 0.2, 3), new THREE.MeshStandardMaterial({ color: 0x9370DB }));
                    blanket.position.set(0, 0.7, 0.8);
                    bedGroup.add(blanket);

                    const pillow1 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.3, 0.8), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    pillow1.position.set(-0.8, 0.75, -1.5);
                    bedGroup.add(pillow1);

                    const pillow2 = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.3, 0.8), new THREE.MeshStandardMaterial({ color: 0xFFFFFF }));
                    pillow2.position.set(0.8, 0.75, -1.5);
                    bedGroup.add(pillow2);

                    const headboard = new THREE.Mesh(new THREE.BoxGeometry(3.8, 1.5, 0.2), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
                    headboard.position.set(0, 1, -2.25);
                    bedGroup.add(headboard);

                    bedGroup.position.set(0, 0, 4);
                    room.add(bedGroup);

                    // Wardrobe
                    const wardrobe = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3.5, 1), new THREE.MeshStandardMaterial({ color: 0x8B4513 }));
                    wardrobe.position.set(5, 1.75, 0);
                    room.add(wardrobe);

                    // Dog Bed
                    const dogBed = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.5, 0.3), new THREE.MeshStandardMaterial({ color: 0xFF69B4 }));
                    dogBed.position.set(-4, 0.15, 0);
                    room.add(dogBed);
                    break;
            }
        }

        function createDog() {
            dog = new THREE.Group();

            // Blue merle collie colors
            const blueMerle = 0x6B7B8C;      // Grey-blue base
            const blackPatches = 0x2A2A2A;   // Black patches
            const whiteMarkings = 0xFAF8F5;  // Cream white
            const tanMarkings = 0xD4A574;    // Tan/copper accents

            // Main body - elongated collie shape
            const bodyGeometry = new THREE.CapsuleGeometry(0.5, 1.6, 8, 16);
            const bodyMaterial = new THREE.MeshStandardMaterial({
                color: blueMerle,
                roughness: 0.9
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.rotation.z = Math.PI / 2;
            body.position.y = 0.9;
            body.castShadow = true;
            dog.add(body);

            // Fluffy chest ruff (white)
            const ruffGeometry = new THREE.SphereGeometry(0.55, 12, 12);
            const ruffMaterial = new THREE.MeshStandardMaterial({
                color: whiteMarkings,
                roughness: 1
            });
            const ruff = new THREE.Mesh(ruffGeometry, ruffMaterial);
            ruff.position.set(0.6, 0.85, 0);
            ruff.scale.set(1, 1.2, 1.3);
            dog.add(ruff);

            // Extra fluffy layers for fur effect
            for (let i = 0; i < 5; i++) {
                const fluffGeometry = new THREE.SphereGeometry(0.3 + Math.random() * 0.15, 8, 8);
                const fluffMaterial = new THREE.MeshStandardMaterial({
                    color: i % 2 === 0 ? blueMerle : blackPatches,
                    roughness: 1
                });
                const fluff = new THREE.Mesh(fluffGeometry, fluffMaterial);
                fluff.position.set(
                    -0.3 + Math.random() * 0.6,
                    0.7 + Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.6
                );
                dog.add(fluff);
            }

            // Collie head - elongated
            const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({
                color: blueMerle,
                roughness: 0.9
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.set(1.1, 1.2, 0);
            head.scale.set(1.1, 1, 0.9);
            head.castShadow = true;
            dog.add(head);

            // White blaze on face
            const blazeGeometry = new THREE.SphereGeometry(0.18, 8, 8);
            const blazeMaterial = new THREE.MeshStandardMaterial({ color: whiteMarkings, roughness: 1 });
            const blaze = new THREE.Mesh(blazeGeometry, blazeMaterial);
            blaze.position.set(1.35, 1.25, 0);
            blaze.scale.set(0.5, 1.2, 0.8);
            dog.add(blaze);

            // Long collie snout
            const snoutGeometry = new THREE.ConeGeometry(0.18, 0.7, 12);
            const snoutMaterial = new THREE.MeshStandardMaterial({ color: blueMerle, roughness: 0.9 });
            const snout = new THREE.Mesh(snoutGeometry, snoutMaterial);
            snout.rotation.z = -Math.PI / 2;
            snout.position.set(1.6, 1.1, 0);
            dog.add(snout);

            // White snout tip
            const snoutTipGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const snoutTip = new THREE.Mesh(snoutTipGeo, blazeMaterial);
            snoutTip.position.set(1.75, 1.05, 0);
            snoutTip.scale.set(1.2, 0.8, 1);
            dog.add(snoutTip);

            // Collie ears (folded tips)
            const earGeometry = new THREE.ConeGeometry(0.12, 0.35, 8);
            const earMaterial = new THREE.MeshStandardMaterial({ color: blackPatches, roughness: 0.9 });

            const leftEar = new THREE.Mesh(earGeometry, earMaterial);
            leftEar.position.set(0.95, 1.55, 0.25);
            leftEar.rotation.x = 0.4;
            leftEar.rotation.z = -0.2;
            dog.add(leftEar);

            const rightEar = new THREE.Mesh(earGeometry, earMaterial);
            rightEar.position.set(0.95, 1.55, -0.25);
            rightEar.rotation.x = -0.4;
            rightEar.rotation.z = -0.2;
            dog.add(rightEar);

            // Fluffy feathered tail
            const tailGroup = new THREE.Group();
            const tailBaseGeo = new THREE.CylinderGeometry(0.08, 0.12, 0.5, 8);
            const tailMaterial = new THREE.MeshStandardMaterial({ color: blueMerle, roughness: 1 });
            const tailBase = new THREE.Mesh(tailBaseGeo, tailMaterial);
            tailGroup.add(tailBase);

            // Tail feathering
            for (let i = 0; i < 4; i++) {
                const featherGeo = new THREE.SphereGeometry(0.12 - i * 0.02, 6, 6);
                const featherMat = new THREE.MeshStandardMaterial({
                    color: i % 2 === 0 ? whiteMarkings : blueMerle,
                    roughness: 1
                });
                const feather = new THREE.Mesh(featherGeo, featherMat);
                feather.position.y = 0.15 + i * 0.12;
                tailGroup.add(feather);
            }
            tailGroup.position.set(-1.0, 1.1, 0);
            tailGroup.rotation.z = Math.PI / 3;
            tailGroup.name = 'tail';
            dog.add(tailGroup);

            // Fluffy legs with feathering
            const legPositions = [
                { x: 0.5, z: 0.25, front: true },
                { x: 0.5, z: -0.25, front: true },
                { x: -0.5, z: 0.25, front: false },
                { x: -0.5, z: -0.25, front: false }
            ];

            legPositions.forEach((pos, i) => {
                const legGroup = new THREE.Group();

                // Main leg
                const legGeometry = new THREE.CylinderGeometry(0.08, 0.06, 0.6, 8);
                const legMaterial = new THREE.MeshStandardMaterial({ color: whiteMarkings, roughness: 0.9 });
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                legGroup.add(leg);

                // Leg feathering (back legs have more)
                if (!pos.front) {
                    const featherGeo = new THREE.SphereGeometry(0.1, 6, 6);
                    const featherMat = new THREE.MeshStandardMaterial({ color: whiteMarkings, roughness: 1 });
                    const feather = new THREE.Mesh(featherGeo, featherMat);
                    feather.position.set(-0.05, 0.1, 0);
                    feather.scale.set(1, 1.5, 0.8);
                    legGroup.add(feather);
                }

                // Paw
                const pawGeo = new THREE.SphereGeometry(0.08, 8, 8);
                const pawMat = new THREE.MeshStandardMaterial({ color: whiteMarkings, roughness: 0.8 });
                const paw = new THREE.Mesh(pawGeo, pawMat);
                paw.position.y = -0.3;
                paw.scale.set(1.2, 0.6, 1.1);
                legGroup.add(paw);

                // Visible nails on each paw - LARGER AND HIGHER
                const nailMat = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.5 });
                for (let n = 0; n < 4; n++) {
                    const nail = new THREE.Mesh(
                        new THREE.ConeGeometry(0.03, 0.1, 8),
                        nailMat.clone() // Clone material for individual emissive highlighting
                    );
                    // y: -0.26 to be above ground (paw is at -0.3, ground at 0.35 offset?)
                    // legGroup y is 0.35. Paw y is -0.3 -> world 0.05.
                    // Nail y -0.26 -> world 0.09. Visible!
                    nail.position.set(0.08, -0.26, -0.06 + n * 0.04);

                    // Rotate to point forward and down
                    nail.rotation.x = Math.PI / 2 + 0.8;

                    nail.name = `nail_${i}_${n}`;
                    legGroup.add(nail);
                }

                legGroup.position.set(pos.x, 0.35, pos.z);
                legGroup.name = `leg${i}`;
                dog.add(legGroup);
            });

            // Expressive eyes - larger and more visible
            const eyeSocketGeo = new THREE.SphereGeometry(0.14, 12, 12);
            const eyeSocketMat = new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.9 });

            const eyeWhiteGeo = new THREE.SphereGeometry(0.12, 12, 12);
            const eyeWhiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff });

            const eyeGeo = new THREE.SphereGeometry(0.08, 12, 12);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x4A2810 }); // Dark brown eyes

            const pupilGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const pupilMat = new THREE.MeshStandardMaterial({ color: 0x000000 });

            [-1, 1].forEach(side => {
                // Eye socket (dark area around eye)
                const eyeSocket = new THREE.Mesh(eyeSocketGeo, eyeSocketMat);
                eyeSocket.position.set(1.28, 1.28, side * 0.22);
                dog.add(eyeSocket);

                // White of eye
                const eyeWhite = new THREE.Mesh(eyeWhiteGeo, eyeWhiteMat);
                eyeWhite.position.set(1.32, 1.28, side * 0.22);
                dog.add(eyeWhite);

                // Brown iris
                const eye = new THREE.Mesh(eyeGeo, eyeMat);
                eye.position.set(1.38, 1.28, side * 0.22);
                dog.add(eye);

                // Black pupil
                const pupil = new THREE.Mesh(pupilGeo, pupilMat);
                pupil.position.set(1.42, 1.28, side * 0.22);
                dog.add(pupil);

                // Eye shine (specular highlight)
                const shineGeo = new THREE.SphereGeometry(0.03, 6, 6);
                const shineMat = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    emissive: 0xffffff,
                    emissiveIntensity: 1
                });
                const shine = new THREE.Mesh(shineGeo, shineMat);
                shine.position.set(1.44, 1.32, side * 0.20);
                dog.add(shine);
            });

            // Black nose
            const noseGeo = new THREE.SphereGeometry(0.07, 10, 10);
            const noseMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.3 });
            const nose = new THREE.Mesh(noseGeo, noseMat);
            nose.position.set(1.9, 1.08, 0);
            nose.scale.set(1.2, 0.8, 1);
            dog.add(nose);

            dog.position.set(0, 0, 2);
            scene.add(dog);
        }

        let walkOffset = 0;
        let tailWag = 0;

        function animate() {
            animationId = requestAnimationFrame(animate);

            // Tail wagging animation
            tailWag += 0.2;
            const tail = dog.getObjectByName('tail');
            if (tail) {
                tail.rotation.x = Math.sin(tailWag) * 0.3;
            }

            // Idle leg movement
            dog.children.forEach(child => {
                if (child.name && child.name.startsWith('leg')) {
                    const legIndex = parseInt(child.name.replace('leg', ''));
                    const offset = legIndex % 2 === 0 ? 0 : Math.PI;
                    child.rotation.x = Math.sin(tailWag * 0.5 + offset) * 0.1;
                }
            });

            // Subtle body bob
            dog.position.y = Math.sin(tailWag * 0.5) * 0.03;

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // ============================================
        // ANIMATIONS
        // ============================================

        function walkToDoor(targetRoom, callback) {
            gameState.isAnimating = true;

            // Dog walks to an exit point
            const startPos = { ...dog.position };
            const exitPos = { x: -5, y: 0, z: 5 }; // Door location

            let progress = 0;
            const walkDuration = 1500;
            const startTime = Date.now();

            function animateWalk() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / walkDuration, 1);

                // Easing
                const eased = 1 - Math.pow(1 - progress, 3);

                dog.position.x = startPos.x + (exitPos.x - startPos.x) * eased;
                dog.position.z = startPos.z + (exitPos.z - startPos.z) * eased;

                // Walking animation - faster leg movement
                walkOffset += 0.3;
                dog.children.forEach(child => {
                    if (child.name && child.name.startsWith('leg')) {
                        const legIndex = parseInt(child.name.replace('leg', ''));
                        const offset = legIndex % 2 === 0 ? 0 : Math.PI;
                        child.rotation.x = Math.sin(walkOffset + offset) * 0.5;
                    }
                });

                // Rotate dog to face direction
                const angle = Math.atan2(exitPos.z - startPos.z, exitPos.x - startPos.x);
                dog.rotation.y = -angle + Math.PI / 2;

                if (progress < 1) {
                    requestAnimationFrame(animateWalk);
                } else {
                    if (callback) callback();
                }
            }

            animateWalk();
            showSpeechBubble(getRoomReaction(targetRoom));
        }

        function enterFromDoor(callback) {
            const startPos = { x: 5, y: 0, z: -5 }; // Entry point
            const endPos = { x: 0, y: 0, z: 2 }; // Center of room

            dog.position.set(startPos.x, startPos.y, startPos.z);
            dog.rotation.y = 0;

            let progress = 0;
            const walkDuration = 1500;
            const startTime = Date.now();

            function animateEnter() {
                const elapsed = Date.now() - startTime;
                progress = Math.min(elapsed / walkDuration, 1);

                const eased = 1 - Math.pow(1 - progress, 3);

                dog.position.x = startPos.x + (endPos.x - startPos.x) * eased;
                dog.position.z = startPos.z + (endPos.z - startPos.z) * eased;

                // Walking animation
                walkOffset += 0.3;
                dog.children.forEach(child => {
                    if (child.name && child.name.startsWith('leg')) {
                        const legIndex = parseInt(child.name.replace('leg', ''));
                        const offset = legIndex % 2 === 0 ? 0 : Math.PI;
                        child.rotation.x = Math.sin(walkOffset + offset) * 0.5;
                    }
                });

                // Face forward
                const angle = Math.atan2(endPos.z - startPos.z, endPos.x - startPos.x);
                dog.rotation.y = -angle + Math.PI / 2;

                if (progress < 1) {
                    requestAnimationFrame(animateEnter);
                } else {
                    dog.rotation.y = 0;
                    gameState.isAnimating = false;
                    if (callback) callback();
                }
            }

            animateEnter();
        }

        // POOP ANIMATION! üí©
        function playPoopAnimation() {
            gameState.isAnimating = true;

            // Dog squats
            const originalY = dog.position.y;

            // Squat down animation
            let squatProgress = 0;
            const squatDuration = 500;
            const squatStartTime = Date.now();

            function animateSquat() {
                const elapsed = Date.now() - squatStartTime;
                squatProgress = Math.min(elapsed / squatDuration, 1);

                // Lower the dog's body
                dog.position.y = originalY - squatProgress * 0.3;

                // Spread back legs
                dog.children.forEach(child => {
                    if (child.name === 'leg2' || child.name === 'leg3') {
                        child.rotation.z = squatProgress * 0.3;
                    }
                });

                if (squatProgress < 1) {
                    requestAnimationFrame(animateSquat);
                } else {
                    // Hold squat, then poop
                    setTimeout(() => {
                        createPoopEmoji();

                        // Return to normal after poop
                        setTimeout(() => {
                            resetDogPose(originalY);
                        }, 1000);
                    }, 500);
                }
            }

            showSpeechBubble('üí© Hups...', 3000);
            animateSquat();
        }

        function createPoopEmoji() {
            // Create 3D poop in the scene
            const poopGroup = new THREE.Group();
            poopGroup.name = 'poop';

            // Base of poop
            const geometries = [
                new THREE.SphereGeometry(0.2, 8, 8),
                new THREE.SphereGeometry(0.17, 8, 8),
                new THREE.SphereGeometry(0.12, 8, 8)
            ];
            const poopMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });

            geometries.forEach((geo, i) => {
                const sphere = new THREE.Mesh(geo, poopMaterial);
                sphere.position.y = i * 0.15;
                poopGroup.add(sphere);
            });

            poopGroup.position.set(dog.position.x - 0.8, 0, dog.position.z);
            scene.add(poopGroup);

            // Track for cleanup
            gameState.poopObjects.push(poopGroup);

            // Also show emoji animation on screen
            const poopEmoji = document.createElement('div');
            poopEmoji.className = 'poop-animation';
            poopEmoji.textContent = 'üí©';
            poopEmoji.style.left = '50%';
            poopEmoji.style.top = '30%';
            document.body.appendChild(poopEmoji);

            setTimeout(() => {
                poopEmoji.remove();
            }, 1500);

            // Update game state
            gameState.stats.bladder = Math.max(0, gameState.stats.bladder - 50);
            updateStatBars();
            showNotification('üí© Viuhti teki tarpeet!');
        }

        // CLEANUP POOP üßπ
        function cleanupPoop() {
            if (gameState.poopObjects.length === 0) {
                showNotification('‚ú® Ei siivottavaa!');
                return;
            }

            gameState.isAnimating = true;
            let cleaned = 0;

            function cleanNext() {
                if (gameState.poopObjects.length === 0) {
                    gameState.isAnimating = false;
                    showNotification(`üßπ Siivottiin ${cleaned} kakkaa!`);
                    showSpeechBubble('Kiitos siivouksesta! ‚ù§Ô∏è');
                    return;
                }

                const poop = gameState.poopObjects.pop();

                // Animate poop disappearing
                let scale = 1;
                function shrinkPoop() {
                    scale -= 0.1;
                    if (scale > 0) {
                        poop.scale.set(scale, scale, scale);
                        requestAnimationFrame(shrinkPoop);
                    } else {
                        scene.remove(poop);
                        cleaned++;
                        setTimeout(cleanNext, 200);
                    }
                }
                shrinkPoop();
            }

            cleanNext();
        }

        // NAIL CLIPPING MINIGAME ‚úÇÔ∏è
        let nailGameActive = false;
        let scissorsMesh = null;
        let originalCamPos = null;
        let originalCamRot = null;
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        let hoveredNail = null;

        function trimNails() {
            if (nailGameActive) return;

            gameState.isAnimating = true;
            nailGameActive = true;
            showNotification('Leikkaa kynnet napsauttamalla! ‚úÇÔ∏è');

            // Add Exit Button
            let btn = document.getElementById('btn-close-minigame');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'btn-close-minigame';
                btn.textContent = '‚ùå Lopeta';
                btn.style.position = 'absolute';
                btn.style.top = '100px';
                btn.style.left = '50%';
                btn.style.transform = 'translateX(-50%)';
                btn.style.padding = '10px 20px';
                btn.style.backgroundColor = '#ff4444';
                btn.style.color = 'white';
                btn.style.border = 'none';
                btn.style.borderRadius = '5px';
                btn.style.cursor = 'pointer';
                btn.style.zIndex = '2000';
                btn.onclick = endNailGame;
                document.body.appendChild(btn);
            }
            btn.style.display = 'block';

            // Save camera
            originalCamPos = camera.position.clone();

            // Focus on FRONT RIGHT PAW (leg0)
            const targetPos = new THREE.Vector3();
            const frontPaw = dog.getObjectByName('leg0');
            if (frontPaw) {
                frontPaw.getWorldPosition(targetPos);
            } else {
                targetPos.copy(dog.position);
            }

            // Camera position: Higher and looking down at the paw
            const endPos = targetPos.clone().add(new THREE.Vector3(0.5, 0.8, 0.8));

            // Smooth transition
            let progress = 0;
            const startPos = camera.position.clone();

            function enterMinigame() {
                progress += 0.04;
                camera.position.lerpVectors(startPos, endPos, progress);
                camera.lookAt(targetPos);

                if (progress < 1) {
                    requestAnimationFrame(enterMinigame);
                } else {
                    // Start interactivity
                    createScissors();
                    window.addEventListener('mousemove', onNailMove);
                    window.addEventListener('click', onNailClick);
                }
            }
            enterMinigame();
        }

        function createScissors() {
            if (scissorsMesh) scene.remove(scissorsMesh); // clear old

            const group = new THREE.Group();
            const steelMat = new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.9, roughness: 0.2 });
            const handleMat = new THREE.MeshStandardMaterial({ color: 0xD32F2F });

            // Blades
            const blade1 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.04, 0.01), steelMat);
            blade1.rotation.z = 0.3;
            group.add(blade1);

            const blade2 = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.04, 0.01), steelMat);
            blade2.rotation.z = -0.3;
            group.add(blade2);

            // Pivot
            const pivot = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.03), steelMat);
            pivot.rotation.x = Math.PI / 2;
            group.add(pivot);

            // Handles
            const handle1 = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.02, 8, 16), handleMat);
            handle1.position.set(-0.35, 0.1, 0);
            group.add(handle1);

            const handle2 = new THREE.Mesh(new THREE.TorusGeometry(0.08, 0.02, 8, 16), handleMat);
            handle2.position.set(-0.35, -0.1, 0);
            group.add(handle2);

            scissorsMesh = group;
            // Configure initial orientation
            scissorsMesh.rotation.y = -Math.PI / 2; // Point left (towards paw if camera is right)

            scene.add(scissorsMesh);
        }

        function onNailMove(event) {
            if (!nailGameActive) return;

            // Correct coordinate calculation relative to canvas
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // Move 3D cursor
            const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
            vector.unproject(camera);
            const dir = vector.sub(camera.position).normalize();
            const distance = 0.5; // Keep scissors close to camera
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            if (scissorsMesh) {
                scissorsMesh.position.copy(pos);
                scissorsMesh.lookAt(camera.position); // Look at user
                scissorsMesh.rotateY(Math.PI); // Flip to point away
            }

            // Hover Effect
            if (hoveredNail) {
                hoveredNail.material.emissive.setHex(0x000000); // Reset old
                hoveredNail = null;
            }

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(dog.children, true);

            for (let intersect of intersects) {
                if (intersect.object.name && intersect.object.name.startsWith('nail_')) {
                    hoveredNail = intersect.object;
                    hoveredNail.material.emissive.setHex(0xFF0000); // Red glow
                    break;
                }
            }
        }

        function onNailClick(event) {
            if (!nailGameActive) return;

            // Update mouse just in case
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            // Search DEEP into dog children (nails are nested in leg groups)
            const intersects = raycaster.intersectObjects(dog.children, true);

            for (let intersect of intersects) {
                if (intersect.object.name && intersect.object.name.startsWith('nail_')) {
                    cutNail(intersect.object);
                    break;
                }
            }
        }

        function cutNail(nail) {
            if (nail.scale.x < 0.4) return;

            // Scissor snip animation (simple)
            if (scissorsMesh) {
                const b1 = scissorsMesh.children[0];
                const b2 = scissorsMesh.children[1];
                b1.rotation.z = 0;
                b2.rotation.z = 0;
                setTimeout(() => {
                    b1.rotation.z = 0.3;
                    b2.rotation.z = -0.3;
                }, 100);
            }

            nail.scale.set(0.3, 0.3, 0.3);

            // Falling piece logic
            const piece = nail.clone();
            const worldPos = new THREE.Vector3();
            nail.getWorldPosition(worldPos);
            piece.position.copy(worldPos);
            piece.scale.set(0.3, 0.3, 0.3);
            // Ensure piece has its own material to avoid affecting the original
            piece.material = nail.material.clone();
            piece.material.emissive.setHex(0x000000);
            scene.add(piece);

            let life = 0;
            function animatePiece() {
                life++;
                piece.position.y -= 0.01;
                piece.rotation.x += 0.1;
                if (life < 50) requestAnimationFrame(animatePiece);
                else scene.remove(piece);
            }
            animatePiece();

            // Check win condition
            let allCut = true;
            dog.traverse(child => {
                if (child.name && child.name.startsWith('nail_') && child.scale.x >= 0.4) {
                    allCut = false;
                }
            });

            if (allCut) {
                showNotification('‚ú® Kaikki leikattu!');
                setTimeout(endNailGame, 1000);
            }
        }

        function endNailGame() {
            nailGameActive = false;
            window.removeEventListener('mousemove', onNailMove);
            window.removeEventListener('click', onNailClick);

            if (scissorsMesh) scene.remove(scissorsMesh);

            const btn = document.getElementById('btn-close-minigame');
            if (btn) btn.style.display = 'none';

            // Reset Hover
            if (hoveredNail) {
                hoveredNail.material.emissive.setHex(0x000000);
                hoveredNail = null;
            }

            // Restore camera
            let progress = 0;
            const startPos = camera.position.clone();

            function leaveMinigame() {
                progress += 0.04;
                camera.position.lerpVectors(startPos, originalCamPos, progress);
                camera.lookAt(0, 0.5, 0);

                if (progress < 1) {
                    requestAnimationFrame(leaveMinigame);
                } else {
                    gameState.isAnimating = false;
                    gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 15);
                    updateStatBars();
                }
            }
            leaveMinigame();
        }

        // INJURY SYSTEM ü©π
        function addRandomInjury() {
            // Random chance to get injured (30%)
            if (Math.random() > 0.3) return null;

            const injuryType = injuryTypes[Math.floor(Math.random() * injuryTypes.length)];
            const injury = {
                ...injuryType,
                id: Date.now(),
                mesh: null
            };

            // Create visual indicator on dog
            const injuryGroup = new THREE.Group();
            injuryGroup.name = `injury_${injury.id}`;

            if (injury.type === 'splinter' || injury.type === 'thorn') {
                // Stick/thorn in paw
                const stick = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.015, 0.01, 0.15, 6),
                    new THREE.MeshStandardMaterial({ color: 0x8B4513 })
                );
                stick.rotation.x = Math.PI / 4;
                stick.rotation.z = Math.random() * 0.5;
                injuryGroup.add(stick);

                // Position on random paw
                const paw = Math.floor(Math.random() * 4);
                const legPos = [
                    { x: 0.5, z: 0.25 },
                    { x: 0.5, z: -0.25 },
                    { x: -0.5, z: 0.25 },
                    { x: -0.5, z: -0.25 }
                ][paw];
                injuryGroup.position.set(legPos.x, 0.1, legPos.z);
            } else {
                // Wound/scratch on body - red mark
                const wound = new THREE.Mesh(
                    new THREE.SphereGeometry(0.08, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0xCC0000,
                        transparent: true,
                        opacity: 0.8
                    })
                );
                injuryGroup.add(wound);

                // Random position on body
                injuryGroup.position.set(
                    (Math.random() - 0.5) * 0.8,
                    0.8 + Math.random() * 0.3,
                    (Math.random() - 0.5) * 0.4
                );
            }

            injury.mesh = injuryGroup;
            dog.add(injuryGroup);
            gameState.injuries.push(injury);

            return injury;
        }

        function healInjuries() {
            if (gameState.injuries.length === 0) {
                showNotification('‚ú® Viuhti on terve!');
                return;
            }

            gameState.isAnimating = true;
            let healed = 0;

            showSpeechBubble('Au! Ole varovainen... üêï');

            function healNext() {
                if (gameState.injuries.length === 0) {
                    gameState.isAnimating = false;
                    showNotification(`ü©π Hoidettiin ${healed} vammaa!`);
                    showSpeechBubble('Kiitos hoidosta! ‚ù§Ô∏è');
                    gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 15);
                    updateStatBars();
                    return;
                }

                const injury = gameState.injuries.pop();

                // Create bandage animation
                const bandage = new THREE.Mesh(
                    new THREE.BoxGeometry(0.15, 0.05, 0.1),
                    new THREE.MeshStandardMaterial({ color: 0xFFE4C4 })
                );

                if (injury.mesh) {
                    bandage.position.copy(injury.mesh.position);
                    bandage.position.y += 0.1;
                    dog.add(bandage);
                }

                // Animate healing
                let healProgress = 0;
                function animateHeal() {
                    healProgress += 0.05;

                    // Fade out injury
                    if (injury.mesh) {
                        injury.mesh.traverse(child => {
                            if (child.material) {
                                child.material.opacity = 1 - healProgress;
                                child.material.transparent = true;
                            }
                        });
                    }

                    // Bandage settles
                    if (bandage) {
                        bandage.position.y -= 0.005;
                    }

                    if (healProgress < 1) {
                        requestAnimationFrame(animateHeal);
                    } else {
                        // Remove injury mesh
                        if (injury.mesh) {
                            dog.remove(injury.mesh);
                        }

                        // Remove bandage after delay
                        setTimeout(() => {
                            dog.remove(bandage);
                        }, 1000);

                        healed++;
                        setTimeout(healNext, 500);
                    }
                }

                animateHeal();
            }

            healNext();
        }

        function checkForInjuryWarning() {
            if (gameState.injuries.length > 0) {
                const injuryNames = gameState.injuries.map(i => i.emoji).join(' ');
                showSpeechBubble(`Auts! ${injuryNames}`, 3000);
            }
        }

        // BRUSHING ANIMATION ü™Æ
        function brushDog() {
            gameState.isAnimating = true;
            showSpeechBubble('Mmm... harjaus! ü™Æ');

            // Create brush
            const brushGroup = new THREE.Group();

            // Brush handle
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.04, 0.4, 8),
                new THREE.MeshStandardMaterial({ color: 0x8B4513 })
            );
            handle.rotation.z = Math.PI / 2;
            brushGroup.add(handle);

            // Brush head
            const brushHead = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.08, 0.25),
                new THREE.MeshStandardMaterial({ color: 0x2F4F4F })
            );
            brushHead.position.x = 0.25;
            brushGroup.add(brushHead);

            // Bristles
            for (let i = 0; i < 20; i++) {
                const bristle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.005, 0.005, 0.08, 4),
                    new THREE.MeshStandardMaterial({ color: 0xC0C0C0 })
                );
                bristle.position.set(
                    0.25,
                    -0.08,
                    -0.1 + (i % 5) * 0.05
                );
                bristle.position.x += Math.floor(i / 5) * 0.03;
                brushGroup.add(bristle);
            }

            brushGroup.position.set(0, 1.5, 0.8);
            scene.add(brushGroup);

            // Brushing motion
            let brushProgress = 0;
            let brushStrokes = 0;
            const maxStrokes = 5;

            function animateBrush() {
                brushProgress += 0.08;

                // Move brush back and forth
                brushGroup.position.x = Math.sin(brushProgress * 3) * 0.8;
                brushGroup.position.z = 0.6 + Math.sin(brushProgress * 2) * 0.2;
                brushGroup.rotation.y = Math.sin(brushProgress * 2) * 0.3;

                // Fur particles flying off
                if (Math.random() > 0.7) {
                    const furParticle = new THREE.Mesh(
                        new THREE.SphereGeometry(0.02, 4, 4),
                        new THREE.MeshStandardMaterial({
                            color: [0x6B7B8C, 0xFAF8F5, 0x2A2A2A][Math.floor(Math.random() * 3)]
                        })
                    );
                    furParticle.position.copy(brushGroup.position);
                    furParticle.position.y -= 0.2;
                    scene.add(furParticle);

                    // Animate particle falling
                    let particleLife = 0;
                    function animateParticle() {
                        particleLife += 0.1;
                        furParticle.position.y -= 0.02;
                        furParticle.position.x += (Math.random() - 0.5) * 0.02;
                        furParticle.position.z += (Math.random() - 0.5) * 0.02;

                        if (particleLife < 1) {
                            requestAnimationFrame(animateParticle);
                        } else {
                            scene.remove(furParticle);
                        }
                    }
                    animateParticle();
                }

                // Check for stroke completion
                if (brushProgress > Math.PI * 2) {
                    brushProgress = 0;
                    brushStrokes++;
                }

                if (brushStrokes < maxStrokes) {
                    requestAnimationFrame(animateBrush);
                } else {
                    // Brushing complete
                    scene.remove(brushGroup);
                    gameState.isAnimating = false;
                    gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 10);
                    updateStatBars();
                    showNotification('ü™Æ Turkki kiilt√§√§!');
                    showSpeechBubble('Oi miten kaunista! ‚ú®');
                }
            }

            animateBrush();
        }

        // TEETH BRUSHING ANIMATION ü¶∑
        function brushTeeth() {
            gameState.isAnimating = true;
            showSpeechBubble('Hampaiden pesu! Aaa... ü¶∑');

            // Open mouth (rotate snout slightly up)
            const originalRotationX = dog.rotation.x;

            // Create toothbrush
            const toothbrushGroup = new THREE.Group();

            // Handle
            const handle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8),
                new THREE.MeshStandardMaterial({ color: 0xFF5722 }) // Orange handle
            );
            handle.rotation.z = Math.PI / 2;
            toothbrushGroup.add(handle);

            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.04, 0.03),
                new THREE.MeshStandardMaterial({ color: 0xFFFFFF })
            );
            head.position.x = 0.28;
            toothbrushGroup.add(head);

            // Bristles
            const bristles = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.03, 0.02),
                new THREE.MeshStandardMaterial({ color: 0x81D4FA }) // Blue bristles
            );
            bristles.position.set(0.28, -0.04, 0);
            toothbrushGroup.add(bristles);

            // Position near mouth
            toothbrushGroup.position.set(1.5, 1.2, 0.3);
            toothbrushGroup.rotation.y = Math.PI / 2;
            scene.add(toothbrushGroup);

            // Animation variables
            let brushTime = 0;
            const maxTime = 150;

            function animateTeethBrushing() {
                brushTime++;

                // Rotate dog head up slightly "Aaa"
                if (brushTime < 20) {
                    dog.rotation.x = -0.2 * (brushTime / 20);
                }

                // Move brush back and forth
                toothbrushGroup.position.z = Math.sin(brushTime * 0.5) * 0.2;
                toothbrushGroup.position.x = 1.5 + Math.cos(brushTime * 0.2) * 0.1;
                toothbrushGroup.rotation.x = Math.sin(brushTime * 0.3) * 0.2;

                // Bubbles/Foam particles
                if (brushTime % 5 === 0) {
                    const bubble = new THREE.Mesh(
                        new THREE.SphereGeometry(0.015, 6, 6),
                        new THREE.MeshStandardMaterial({ color: 0xFFFFFF, transparent: true, opacity: 0.8 })
                    );

                    // Position near brush head
                    const worldPos = new THREE.Vector3();
                    bristles.getWorldPosition(worldPos);
                    bubble.position.copy(worldPos);

                    // Add some random offset
                    bubble.position.x += (Math.random() - 0.5) * 0.1;
                    bubble.position.y += (Math.random() - 0.5) * 0.1;
                    bubble.position.z += (Math.random() - 0.5) * 0.1;

                    scene.add(bubble);

                    // Animate bubble falling/popping
                    let bubbleLife = 0;
                    function animateBubble() {
                        bubbleLife++;
                        bubble.position.y -= 0.01;
                        bubble.scale.multiplyScalar(0.95);

                        if (bubbleLife < 30) {
                            requestAnimationFrame(animateBubble);
                        } else {
                            scene.remove(bubble);
                        }
                    }
                    animateBubble();
                }

                if (brushTime < maxTime) {
                    requestAnimationFrame(animateTeethBrushing);
                } else {
                    // Finish
                    scene.remove(toothbrushGroup);

                    // Reset head rotation
                    dog.rotation.x = originalRotationX;

                    // Sparkles! ‚ú®
                    for (let i = 0; i < 5; i++) {
                        const sparkle = new THREE.Mesh(
                            new THREE.OctahedronGeometry(0.05, 0),
                            new THREE.MeshBasicMaterial({ color: 0xFFFF00 })
                        );
                        sparkle.position.set(1.6 + (Math.random() - 0.5) * 0.2, 1.1 + (Math.random() - 0.5) * 0.2, (Math.random() - 0.5) * 0.3);
                        scene.add(sparkle);

                        let sparkleTime = 0;
                        function animateSparkle() {
                            sparkleTime += 0.1;
                            sparkle.rotation.z += 0.2;
                            sparkle.scale.multiplyScalar(0.9);

                            if (sparkleTime < 3) {
                                requestAnimationFrame(animateSparkle);
                            } else {
                                scene.remove(sparkle);
                            }
                        }
                        animateSparkle();
                    }

                    gameState.isAnimating = false;
                    gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 5);
                    gameState.stats.energy = Math.min(100, gameState.stats.energy + 5); // Fresh feeling!
                    updateStatBars();
                    showNotification('ü¶∑ Hampaat hohtavat!');
                    showSpeechBubble('Hraikas hymy! üòÅ‚ú®');
                }
            }

            animateTeethBrushing();
        }

        function resetDogPose(originalY) {
            let resetProgress = 0;
            const resetDuration = 300;
            const resetStartTime = Date.now();

            function animateReset() {
                const elapsed = Date.now() - resetStartTime;
                resetProgress = Math.min(elapsed / resetDuration, 1);

                dog.position.y = (originalY - 0.3) + resetProgress * 0.3;

                dog.children.forEach(child => {
                    if (child.name === 'leg2' || child.name === 'leg3') {
                        child.rotation.z = 0.3 * (1 - resetProgress);
                    }
                });

                if (resetProgress < 1) {
                    requestAnimationFrame(animateReset);
                } else {
                    gameState.isAnimating = false;
                }
            }

            animateReset();
        }

        // OUTDOOR WALKING ANIMATION üö∂ with leash and changing scenery!
        let leashGroup = null;

        function addLeashAndHarness() {
            leashGroup = new THREE.Group();

            // Harness on dog (around chest)
            const harnessMat = new THREE.MeshStandardMaterial({ color: 0xDC143C, roughness: 0.6 });

            // Chest strap
            const chestStrap = new THREE.Mesh(
                new THREE.TorusGeometry(0.45, 0.04, 8, 16),
                harnessMat
            );
            chestStrap.rotation.y = Math.PI / 2;
            chestStrap.position.set(0.3, 0.9, 0);
            leashGroup.add(chestStrap);

            // Back strap
            const backStrap = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.08, 0.08),
                harnessMat
            );
            backStrap.position.set(0, 1.1, 0);
            leashGroup.add(backStrap);

            // D-ring (where leash attaches)
            const dRing = new THREE.Mesh(
                new THREE.TorusGeometry(0.08, 0.02, 6, 12),
                new THREE.MeshStandardMaterial({ color: 0xC0C0C0, metalness: 0.8 })
            );
            dRing.position.set(-0.1, 1.2, 0);
            dRing.rotation.x = Math.PI / 2;
            leashGroup.add(dRing);

            // Leash line (flexible curve)
            const leashMat = new THREE.MeshStandardMaterial({ color: 0x8B0000 });
            for (let i = 0; i < 8; i++) {
                const segment = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.02, 0.4, 6),
                    leashMat
                );
                segment.position.set(-0.5 - i * 0.3, 1.5 + Math.sin(i * 0.5) * 0.2, 0);
                segment.rotation.z = Math.PI / 2 + Math.sin(i * 0.3) * 0.2;
                segment.name = 'leashSegment';
                leashGroup.add(segment);
            }

            // Human hand holding leash
            const handMat = new THREE.MeshStandardMaterial({ color: 0xE8BEAC });
            const hand = new THREE.Mesh(
                new THREE.SphereGeometry(0.15, 8, 8),
                handMat
            );
            hand.position.set(-3, 1.8, 0);
            hand.scale.set(1.2, 0.8, 0.6);
            leashGroup.add(hand);

            // Fingers
            for (let i = 0; i < 4; i++) {
                const finger = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.03, 0.12, 4, 8),
                    handMat
                );
                finger.position.set(-3.1, 1.7, -0.1 + i * 0.06);
                finger.rotation.z = 0.3;
                leashGroup.add(finger);
            }

            // Thumb
            const thumb = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.03, 0.1, 4, 8),
                handMat
            );
            thumb.position.set(-2.9, 1.85, 0.1);
            thumb.rotation.z = -0.5;
            leashGroup.add(thumb);

            dog.add(leashGroup);
            gameState.hasLeash = true;
        }

        function removeLeashAndHarness() {
            if (leashGroup && dog) {
                dog.remove(leashGroup);
                leashGroup = null;
                gameState.hasLeash = false;
            }
        }

        function playOutdoorWalkAnimation() {
            gameState.isAnimating = true;

            // Add leash and harness
            addLeashAndHarness();
            showSpeechBubble('Lenkille valjaat p√§√§ll√§! ü¶Æ');

            // Multiple scenery types to cycle through
            const sceneryTypes = ['park', 'forest', 'street'];
            let currentScenery = 0;

            // Long walking path with scenery changes
            const waypoints = [
                { x: 0, z: 2, scenery: 'park' },
                { x: 6, z: 2, scenery: 'park' },
                { x: 6, z: -8, scenery: 'forest' },
                { x: -6, z: -8, scenery: 'forest' },
                { x: -6, z: 4, scenery: 'street' },
                { x: 0, z: 4, scenery: 'street' },
                { x: 0, z: 2, scenery: 'park' }
            ];

            let currentWaypoint = 0;

            function changeScenery(type) {
                // Clear old scenery
                const toRemove = [];
                room.children.forEach(child => {
                    if (child.name === 'sceneryItem') {
                        toRemove.push(child);
                    }
                });
                toRemove.forEach(item => room.remove(item));

                // Add new scenery based on type
                if (type === 'park') {
                    renderer.setClearColor(0x87CEEB); // Blue sky
                    // Park benches
                    const benchGeo = new THREE.BoxGeometry(1.5, 0.1, 0.5);
                    const benchMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
                    [-8, 8].forEach(x => {
                        const bench = new THREE.Mesh(benchGeo, benchMat);
                        bench.position.set(x, 0.4, 0);
                        bench.name = 'sceneryItem';
                        room.add(bench);
                    });
                    showNotification('üå≥ Puistossa k√§vely√§!');
                } else if (type === 'forest') {
                    renderer.setClearColor(0x4a7c59); // Forest green sky
                    // Dense trees
                    for (let i = 0; i < 10; i++) {
                        const treeGroup = new THREE.Group();
                        treeGroup.name = 'sceneryItem';

                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.3, 2.5, 8),
                            new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                        );
                        trunk.position.y = 1.25;
                        treeGroup.add(trunk);

                        const leaves = new THREE.Mesh(
                            new THREE.ConeGeometry(1.2, 2.5, 8),
                            new THREE.MeshStandardMaterial({ color: 0x1a5f1a })
                        );
                        leaves.position.y = 3;
                        treeGroup.add(leaves);

                        treeGroup.position.set(
                            (Math.random() - 0.5) * 25,
                            0,
                            -12 + Math.random() * 8
                        );
                        room.add(treeGroup);
                    }
                    showNotification('üå≤ Mets√§polulla!');
                } else if (type === 'street') {
                    renderer.setClearColor(0x708090); // Grey sky
                    // Street elements
                    const sidewalk = new THREE.Mesh(
                        new THREE.PlaneGeometry(4, 30),
                        new THREE.MeshStandardMaterial({ color: 0x808080 })
                    );
                    sidewalk.rotation.x = -Math.PI / 2;
                    sidewalk.position.y = 0.02;
                    sidewalk.name = 'sceneryItem';
                    room.add(sidewalk);

                    // Street lamp
                    const lampPost = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
                    );
                    lampPost.position.set(3, 2, 0);
                    lampPost.name = 'sceneryItem';
                    room.add(lampPost);

                    const lamp = new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 8, 8),
                        new THREE.MeshStandardMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 0.5 })
                    );
                    lamp.position.set(3, 4.2, 0);
                    lamp.name = 'sceneryItem';
                    room.add(lamp);

                    showNotification('üèôÔ∏è Kadulla k√§vely√§!');
                }
            }

            function walkToNextPoint() {
                if (currentWaypoint >= waypoints.length) {
                    // Walk complete
                    removeLeashAndHarness();
                    gameState.isAnimating = false;
                    gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 25);
                    gameState.stats.bladder = Math.max(0, gameState.stats.bladder - 40);
                    gameState.stats.energy = Math.max(0, gameState.stats.energy - 15);
                    updateStatBars();
                    showNotification('üêï Mahtava lenkki!');
                    showSpeechBubble('Ihanaa oli lenkkeill√§! ‚ù§Ô∏è');

                    // Reset to park scenery
                    changeScenery('park');

                    // Chance of injury during walk
                    const injury = addRandomInjury();
                    if (injury) {
                        setTimeout(() => {
                            showNotification(`‚ö†Ô∏è ${injury.emoji} ${injury.name}!`);
                            showSpeechBubble('Auts! Sattuu! üò¢');
                        }, 1500);
                    }
                    return;
                }

                const target = waypoints[currentWaypoint];
                const startPos = { x: dog.position.x, z: dog.position.z };

                // Change scenery if needed
                if (target.scenery !== sceneryTypes[currentScenery]) {
                    currentScenery = sceneryTypes.indexOf(target.scenery);
                    changeScenery(target.scenery);
                }

                const distance = Math.sqrt(
                    Math.pow(target.x - startPos.x, 2) +
                    Math.pow(target.z - startPos.z, 2)
                );
                const duration = distance * 180; // Slightly faster

                let progress = 0;
                const startTime = Date.now();

                function animateWalkSegment() {
                    const elapsed = Date.now() - startTime;
                    progress = Math.min(elapsed / duration, 1);

                    dog.position.x = startPos.x + (target.x - startPos.x) * progress;
                    dog.position.z = startPos.z + (target.z - startPos.z) * progress;

                    // Energetic walking animation
                    walkOffset += 0.3;
                    dog.children.forEach(child => {
                        if (child.name && child.name.startsWith('leg')) {
                            const legIndex = parseInt(child.name.replace('leg', ''));
                            const offset = legIndex % 2 === 0 ? 0 : Math.PI;
                            child.rotation.x = Math.sin(walkOffset + offset) * 0.7;
                        }
                    });

                    // Leash sway animation
                    if (leashGroup) {
                        leashGroup.children.forEach((child, i) => {
                            if (child.name === 'leashSegment') {
                                child.rotation.z = Math.PI / 2 + Math.sin(walkOffset * 0.5 + i * 0.3) * 0.15;
                            }
                        });
                    }

                    // Rotate to face direction
                    const angle = Math.atan2(target.z - startPos.z, target.x - startPos.x);
                    dog.rotation.y = -angle + Math.PI / 2;

                    if (progress < 1) {
                        requestAnimationFrame(animateWalkSegment);
                    } else {
                        currentWaypoint++;
                        walkToNextPoint();
                    }
                }

                animateWalkSegment();
            }

            walkToNextPoint();
        }

        // ============================================
        // UI FUNCTIONS
        // ============================================

        function showSpeechBubble(text, duration = 2500) {
            const bubble = document.getElementById('speech-bubble');
            bubble.textContent = text;
            bubble.classList.add('visible');

            // Position above dog in screen space
            const vector = new THREE.Vector3();
            vector.setFromMatrixPosition(dog.matrixWorld);
            vector.y += 2;
            vector.project(camera);

            const container = document.getElementById('canvas-container');
            const x = (vector.x * 0.5 + 0.5) * container.clientWidth;
            const y = (-(vector.y * 0.5) + 0.5) * container.clientHeight - 50;

            bubble.style.left = `${x}px`;
            bubble.style.top = `${y}px`;

            setTimeout(() => {
                bubble.classList.remove('visible');
            }, duration);
        }

        function showNotification(text) {
            const notification = document.getElementById('notification');
            notification.textContent = text;
            notification.classList.add('visible');

            setTimeout(() => {
                notification.classList.remove('visible');
            }, 2500);
        }

        function getRoomReaction(roomId) {
            const reactions = {
                living: 'Olohuoneeseen! üè†',
                kitchen: 'Ruokaa? üçñ',
                bathroom: 'Pesulle! üõÅ',
                bedroom: 'Nukkumaan... üò¥',
                yard: 'ULOS! üå≥'
            };
            return reactions[roomId] || 'Hau!';
        }

        function updateStatBars() {
            Object.keys(gameState.stats).forEach(stat => {
                const bar = document.getElementById(`${stat}-bar`);
                if (bar) {
                    bar.style.width = `${gameState.stats[stat]}%`;
                }
            });
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================

        document.querySelectorAll('.room-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (gameState.isAnimating) return;

                const targetRoom = btn.dataset.room;
                if (targetRoom === gameState.currentRoom) return;

                // Update active button
                document.querySelectorAll('.room-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');

                // Animate transition
                walkToDoor(targetRoom, () => {
                    gameState.currentRoom = targetRoom;
                    createRoom(targetRoom);

                    // Reset sky color for indoor
                    if (!roomPositions[targetRoom].isOutside) {
                        renderer.setClearColor(0x1a1a2e);
                    }

                    enterFromDoor();
                });
            });
        });

        // Action buttons
        document.getElementById('btn-feed').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            gameState.stats.hunger = Math.min(100, gameState.stats.hunger + 25);
            gameState.stats.bladder = Math.min(100, gameState.stats.bladder + 15);
            updateStatBars();
            showSpeechBubble('Nam nam! üçñ');
            showNotification('üçñ Ruokittiin Viuhtia!');
        });

        document.getElementById('btn-water').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            gameState.stats.hunger = Math.min(100, gameState.stats.hunger + 10);
            gameState.stats.bladder = Math.min(100, gameState.stats.bladder + 20);
            updateStatBars();
            showSpeechBubble('Raikasta! üíß');
            showNotification('üíß Annettiin vett√§!');
        });

        document.getElementById('btn-pet').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 15);
            updateStatBars();
            showSpeechBubble('Mmm... rapsutuksia! ‚ù§Ô∏è');
            showNotification('ü§≤ Rapsutettiin Viuhtia!');
        });

        document.getElementById('btn-play').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            gameState.stats.happiness = Math.min(100, gameState.stats.happiness + 20);
            gameState.stats.energy = Math.max(0, gameState.stats.energy - 10);
            updateStatBars();
            showSpeechBubble('Leikit√§√§n! üéæ');
            showNotification('üéæ Leikittiin Viuhtin kanssa!');
        });

        document.getElementById('btn-walk').addEventListener('click', () => {
            if (gameState.isAnimating) return;

            if (gameState.currentRoom !== 'yard') {
                showNotification('‚ö†Ô∏è Mene ensin pihalle ulkoillaksesi!');
                return;
            }

            playOutdoorWalkAnimation();
        });

        document.getElementById('btn-poop').addEventListener('click', () => {
            if (gameState.isAnimating) return;

            if (gameState.stats.bladder < 20) {
                showNotification('üí≠ Viuhtilla ei ole h√§t√§√§!');
                return;
            }

            playPoopAnimation();
        });

        // Cleanup button
        document.getElementById('btn-cleanup').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            cleanupPoop();
        });

        // Nail clipping button
        document.getElementById('btn-nails').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            trimNails();
        });

        // Heal injuries button
        document.getElementById('btn-heal').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            healInjuries();
        });

        // Brushing button
        document.getElementById('btn-brush').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            brushDog();
        });

        // Teeth brushing button
        document.getElementById('btn-teeth').addEventListener('click', () => {
            if (gameState.isAnimating) return;
            brushTeeth();
        });

        // Increase bladder over time
        setInterval(() => {
            if (!gameState.isAnimating) {
                gameState.stats.bladder = Math.min(100, gameState.stats.bladder + 2);
                gameState.stats.hunger = Math.max(0, gameState.stats.hunger - 1);
                gameState.stats.energy = Math.max(0, gameState.stats.energy - 0.5);
                updateStatBars();

                // Warning when bladder is high
                if (gameState.stats.bladder >= 80) {
                    showSpeechBubble('Vessah√§t√§!! üöΩ');
                }
            }
        }, 5000);

        // Initialize
        init();
    </script>
</body>

</html>